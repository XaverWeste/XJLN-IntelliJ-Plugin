{
  parserClass="com.github.xjln.xjlnintellijplugin._XJLNParser"
  parserUtilClass="com.github.xjln.xjlnintellijplugin.XJLNParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="XJLN"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.xjln.xjlnintellijplugin.psi"
  psiImplPackage="com.github.xjln.xjlnintellijplugin.psi.impl"

  elementTypeHolderClass="com.github.xjln.xjlnintellijplugin.psi.XJLNTypes"
  elementTypeClass="com.github.xjln.xjlnintellijplugin.psi.XJLNElementType"
  tokenTypeClass="com.github.xjln.xjlnintellijplugin.psi.XJLNTokenType"

  tokens = [
    //Keywords
    KEYWORD_USE = "use"
    KEYWORD_FROM = "from"
    KEYWORD_AS = "as"
    KEYWORD_DEF = "def"
    KEYWORD_ABSTRACT = "abstract"
    KEYWORD_INNER = "inner"
    KEYWORD_CONST = "const"
    KEYWORD_VAR = "var"
    KEYWORD_MAIN = "main"
    KEYWORD_INIT = "init"
    KEYWORD_RETURN = "return"
    KEYWORD_END = "end"
    KEYWORD_IF = "if"
    KEYWORD_ELSE = "else"
    KEYWORD_WHILE = "while"
    KEYWORD_FOR = "for"
    KEYWORD_IN = "in"
    KEYWORD_INT = "int"
    KEYWORD_DOUBLE = "double"
    KEYWORD_FLOAT = "float"
    KEYWORD_LONG = "long"
    KEYWORD_SHORT = "short"
    KEYWORD_BOOLEAN = "boolean"
    KEYWORD_CHAR = "char"
    KEYWORD_BYTE = "byte"

    COMMA = ","

    NEW_LINE = "regexp:\n"
    LETTER = "regexp:[a-zA-Z]"
    DIGIT = "regexp:[0-9]"
    OPERATOR = "regexp:[-+*/%&|<>=!^]"
    CHAR = "regexp:'.'"
    DOC = "regexp:##[^\n]*"
    COMMENT = "regexp:#[^[#\n]][^\n]*"
    STRING = "regexp:\"[^\"]*\""
  ]
}

xjlnFile ::= argument? (NEW_LINE argument?)* (main (NEW_LINE argument?)*)?
argument ::= (COMMENT | record | enum | class | method | field | use)
docs ::= DOC (NEW_LINE DOC)* NEW_LINE
identifier ::= LETTER (LETTER | DIGIT)*
operator ::= OPERATOR+
integer ::= DIGIT+
number ::= integer ('.' integer)?
enum ::= docs? KEYWORD_DEF identifier '=' enumValue ('|' identifier)*
enumValue ::= identifier
record ::= docs? KEYWORD_DEF identifier '=' '[' parameterList ']'
class ::= docs? (KEYWORD_DEF | KEYWORD_ABSTRACT) identifier '[' parameterList ']' ('=>' objectCreation (COMMA objectCreation)*)? NEW_LINE (classArgument? NEW_LINE)* (init (classArgument? NEW_LINE)*)? KEYWORD_END
classArgument ::= (COMMENT | classMethod | abstractMethod | field)
parameterList ::= (parameter (COMMA parameter)*)?
parameter ::= (varWithoutValue | var)
varWithoutValue ::= KEYWORD_CONST? type identifier
var ::= KEYWORD_CONST? type? identifier '=' calc
type ::= (KEYWORD_VAR | primitiveType | complexType | arrayType)
primitiveType ::= (KEYWORD_INT | KEYWORD_DOUBLE | KEYWORD_FLOAT | KEYWORD_LONG | KEYWORD_SHORT | KEYWORD_BOOLEAN | CHAR | KEYWORD_BYTE)
complexType ::= identifier
arrayType ::= '[' type ']'
main ::= KEYWORD_MAIN (methodCode | methodStatement)
init ::= KEYWORD_INIT (methodCode | methodStatement)
methodEqual ::= '=' calc
methodStatement ::= '->' statement
methodCode ::= NEW_LINE (statement? NEW_LINE)* KEYWORD_END
statement ::= (COMMENT | ifStatement | whileStatement | forStatement | var | returnStatement)
whileStatement ::= KEYWORD_WHILE calc (methodCode | methodStatement)
forStatement ::= KEYWORD_FOR type? identifier KEYWORD_IN calc (methodCode | methodStatement)
ifStatement ::= KEYWORD_IF (methodCode | methodStatement) elseStatement*
elseStatement ::= KEYWORD_ELSE (ifStatement | (methodCode | methodStatement))
returnStatement ::= KEYWORD_RETURN calc
objectCreation ::= identifier '[' (calc (COMMA calc)*)? ']'
arrayCreation ::= (('[' type (COMMA integer)+ ']') | ('{' (calc (COMMA calc)*)? '}'))
method ::= KEYWORD_DEF identifier '(' parameterList ')' ('::' type)? (methodEqual | methodStatement | methodCode)
abstractMethod ::= KEYWORD_ABSTRACT KEYWORD_INNER? identifier '(' parameterList ')' ('::' type)?
classMethod ::= KEYWORD_DEF KEYWORD_INNER? (identifier | operator) '(' parameterList ')' ('::' type)? (methodEqual | methodStatement | methodCode)
field ::= KEYWORD_INNER? var
use ::= KEYWORD_USE (useFromPath | singleUse | multiUse)
useFromPath ::= path (KEYWORD_AS identifier)?
singleUse ::= identifier KEYWORD_FROM path (KEYWORD_AS identifier)?
multiUse ::= identifier (COMMA identifier)+ KEYWORD_FROM path
path ::= identifier ('/' identifier)+
calc ::= calcArg (operator calcArg)+
calcArg ::= operator? (value | '(' calc ')')
call ::= (objectCreation | arrayCreation | methodCall | identifier) (':' (methodCall | identifier))*
methodCall ::= identifier '(' (calc (COMMA calc)*)? ')'
value ::= (number | integer | STRING | CHAR | call)