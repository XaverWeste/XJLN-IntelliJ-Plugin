{
  parserClass="com.github.xjln.xjlnintellijplugin._XJLNParser"
  parserUtilClass="com.github.xjln.xjlnintellijplugin.XJLNParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="XJLN"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.xjln.xjlnintellijplugin.psi"
  psiImplPackage="com.github.xjln.xjlnintellijplugin.psi.impl"

  elementTypeHolderClass="com.github.xjln.xjlnintellijplugin.psi.XJLNTypes"
  elementTypeClass="com.github.xjln.xjlnintellijplugin.psi.XJLNElementType"
  tokenTypeClass="com.github.xjln.xjlnintellijplugin.psi.XJLNTokenType"

  tokens = [
    //Keywords
    KEYWORD_USE = "use"
    KEYWORD_FROM = "from"
    KEYWORD_AS = "as"
    KEYWORD_DEF = "def"
    KEYWORD_ABSTRACT = "abstract"
    KEYWORD_INNER = "inner"
    KEYWORD_CONST = "const"
    KEYWORD_VAR = "var"
    KEYWORD_MAIN = "main"
    KEYWORD_INIT = "init"
    KEYWORD_RETURN = "return"
    KEYWORD_END = "end"
    PRIMITIVETYPE = "regexp:(int) | (double) | (float) | (long) | (short) | (boolean) | (char) | (byte)"

    COMMA = ","

    NEW_LINE = "regexp:\n"
    PATH = "regexp:[a-zA-Z]+(/[a-zA-Z]+)+"
    IDENTIFIER = "regexp:[a-zA-Z][a-zA-Z0-9]*"
    OPPERATOR = "regexp:[-+*/%&|<>=!^]+"
    DIGITS_FLOATING_POINT = "regexp:[0-9]+\.[0-9]+"
    DIGITS = "regexp:[0-9]+"
    CHAR = "regexp:'.'"
    DOC = "regexp:##[^\n]*"
    COMMENT = "regexp:#[^[#\n]][^\n]*"
    STRING = "regexp:\"[^\"]*\""
  ]
}

xjlnFile ::= (argument_? (NEW_LINE argument_?)*)?
private argument_ ::= (COMMENT | use | enum | record | clazz | field | main | methodDefMain)
private docs ::= (DOC NEW_LINE)*

use ::= KEYWORD_USE ((PATH) | (('{' IDENTIFIER (COMMA IDENTIFIER)* '}') | (IDENTIFIER)) KEYWORD_FROM PATH) (KEYWORD_AS IDENTIFIER)?
enum ::= docs KEYWORD_DEF IDENTIFIER '=' IDENTIFIER ('|' IDENTIFIER)*
record ::= docs KEYWORD_DEF IDENTIFIER '=' '[' parameterList ']'
clazz ::= docs (KEYWORD_DEF | KEYWORD_ABSTRACT) IDENTIFIER '[' parameterList ']' ('=>' )? NEW_LINE (methodDef | abstractMethod | init | (field NEW_LINE) | NEW_LINE)* KEYWORD_END

main ::= KEYWORD_MAIN (methodShort | methodCode)
methodDefMain ::= KEYWORD_DEF IDENTIFIER '(' parameterList ')' ('::' (IDENTIFIER | PRIMITIVETYPE))? (((methodShort | methodEquals) NEW_LINE) | methodCode | methodDefMulti)

parameterList ::= (var (COMMA var)*)?
var ::= KEYWORD_CONST? ((type IDENTIFIER) | (type? IDENTIFIER '=' calc))
field ::= KEYWORD_INNER? var
type ::= (PRIMITIVETYPE | IDENTIFIER | '[' IDENTIFIER ']')

methodDef ::= KEYWORD_DEF (IDENTIFIER | OPPERATOR) '(' parameterList ')' ('::' (IDENTIFIER | PRIMITIVETYPE))? (((methodShort | methodEquals) NEW_LINE)  | methodCode | methodDefMulti)
abstractMethod ::= KEYWORD_ABSTRACT (IDENTIFIER | OPPERATOR) '(' parameterList ')' ('::' (IDENTIFIER | PRIMITIVETYPE))? NEW_LINE
init ::= KEYWORD_INIT (methodShort | methodCode) NEW_LINE

varCall ::= IDENTIFIER
methodCall ::= IDENTIFIER '(' parameterListArguments ')'
parameterListArguments ::= (calc (COMMA calc)*)?

objCreation ::= IDENTIFIER '[' parameterListArguments ']'
arrCreation ::= '[' IDENTIFIER (COMMA DIGITS)+']'

call ::= (methodCall | varCall | objCreation | arrCreation) (':' (methodCall | varCall))*

calc ::= OPPERATOR? calcArg (OPPERATOR OPPERATOR? calcArg)*
calcArg ::= (call | ('(' calc ')') | STRING | CHAR | DIGITS | DIGITS_FLOATING_POINT)

methodDefMulti ::= '{' ('(' calc ')' ((methodShort | methodEquals) NEW_LINE) | methodCode)* NEW_LINE '}' NEW_LINE

methodShort ::= '->' statement
methodEquals ::= '=' calc
methodCode ::= NEW_LINE (statement NEW_LINE)* KEYWORD_END NEW_LINE

statement ::= ((KEYWORD_RETURN (call | calc)) | var | calc | call)